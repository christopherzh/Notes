# 动态内存
## 动态内存与智能指针
除了静态内存和栈内存，每个程序还拥有一个内存池。这部分内存被称作自由空间或堆。程序用堆来存储动态分配的对象（在程序运行时分配的对象）。动态对象的生存期由程序来控制，也就是说，当动态对象不再使用时，我们的代码必须显式地销毁它们。

智能指针的行为类似常规指针，重要的区别是它负责自动释放所指向的对象。新标准库提供的这两种智能指针的区别在于管理底层指针的方式：`shared_ptr`允许多个指针指向同一个对象： `unique_ptr`则“独占”所指向的对象。标准库还定义了一个名为`weak_ptr`的伴随类，它是一种弱引用，指向`shared_ptr`所管理的对象。这三种类型都定义在memory头文件中。

### `shared_ptr`类
智能指针是一个模板类，当我们创建一个智能指针时，必须提供指针可以指向的类型。默认初始化的智能指针中保存着一个空指针。
```CPP
shared_ptr<string> p1;
 ```

![](image/2023-03-27-11-09-14.png)

#### `make_shared`函数
最安全的分配和使用动态内存的方法是调用一个名为`make_shared`的标准库函数。此函数在动态内存中分配一个对象并初始化它，返回指向此对象的shared_ptr。
```CPP
shared_ptr<string> p1 = make_shared<string>("asd");
auto p2 = make_shared<string>("asd"); //使用auto简化
 ```
#### `shared_ptr`的拷贝和赋值
我们可以认为每个shared_ ptr都有一个关联的计数器，通常称其为**引用计数**。无论何时我们拷贝一个shared_ptr（拷贝初始化、作为参数传递给一个函数，作为函数的返回值）, 计数器都会递增。当我们给shared_ptr赋予一个新值或是shared_ptr被销毁（例如一个局部的shared_ptr离开其作用域时），计数器就会递减。

#### `shared_ptr`的的自动销毁对象与自动释放内存
shared_ ptr的析构函数会递减它所指向的对象的引用计数。如果引用计数变为0，shared_ptr的析构函数就会销毁对象，并释放它占用的内存。