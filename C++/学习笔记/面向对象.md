# OOP
## 基类与派生类
### 一些须知
1. 基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作。
2. 积累在成员函数声明之前加上`virtual`将其定义为虚函数，任何构造函数之外的非静态函数都可以是虚函数，`virtual`只能出现在类内部的声明，而不能出现在类外部的定义。使用`override`关键词在函数后面(`void func() const & overide{};`)，以显式的注明该函数覆盖了它继承的虚函数。
3. 每个类控制它自己的成员初始化过程。首先初始化基类的部分，然后按照声明的顺序初始化派生类成员。派生类应该通过调用基类的构造函数初始化从基类继承的成员，而不是自己初始化它们。
4. 基类的静态成员在整个继承体系中只存在成员的唯一定义。静态成员遵守通用的访问控制规则。
5. 派生类的声明包含类名但不包含它的派生列表。如果想将某个类做基类，则该类必须已经定义而非仅仅声明。
6. 在类名后面使用`final`关键词(`class Quote final{};`)，防止该类被继承。
### 类型转换与继承
1. 在派生类对象中含有与基类对应的组成部分，这是继承的关键所在。
2. 存在派生类到基类的自动类型转换，例如，将派生类对象的引用或指针用在需要基类引用或指针的地方。智能指针也支持这种转换，因此可以将一个派生类对象的指针存在一个积累的智能指针里。
3. 不存在基类到派生类的自动类型转换。但当基类中含有一或多个虚函数，可以使用`dynamic_cast`请求一个类型转换，其安全检查在运行时执行。如果已知基类到派生类的类型转换是安全的，可以使用`static_cast`强制覆盖掉编译器的检查工作。
4. 派生类到基类的自动类型转换只对指针或引用有效，在派生类类型和基类类型之间不存在这样的转换。当我们用一个派生类对象为一个基类对象初始化或赋值时，只有派生类对象中的基类部分会被拷贝、移动或赋值（使用基类中对应的函数，需要进行参数类型转换），它的派生类部分将被忽略掉。
5. 区分变量或表达式的**静态类型与动态类型**：静态类型在编译时已知，它是变量声明时的类型或表达式生成的类型。动态类型是变量或表达式表示的内存中的对象的类型，直到运行时才可知。
6. 如果表达式既不是引用也不是指针，那它的动态类型永远与静态类型一致。基类的指针或引用的静态类型可能与其动态类型不一致。

## 虚函数
## 多态与虚函数 
[C++之多态性](https://blog.csdn.net/studyhardi/article/details/90815766?spm=1001.2101.3001.6650.5&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-5.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-5.pc_relevant_default&utm_relevant_index=10)
[C++ 多态的实现及原理](https://www.cnblogs.com/cxq0017/p/6074247.html)
[C++虚函数和虚函数表原理](https://blog.csdn.net/u012630961/article/details/81226351)
[虚函数实现原理](https://blog.csdn.net/wanghaobo920/article/details/7674631?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_antiscanv2&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_antiscanv2&utm_relevant_index=1)
1. 多态是利用虚函数与虚函数表来实现的，通过指向对象的指针来调用类中的函数时，系统会根据指针指向的对象的类（而不是该指针定义时的类型）来决定调用哪个函数（父类的方法为虚函数）；该过程是通过对象中一个指向虚函数表的指针来实现调用的，也称为“晚绑定” （要让编译器采用晚绑定，就要在基类中声明函数时使用virtual关键字，这样的函数我们就称之为虚函数，一旦某个函数在基类中声明为virtual，那么在所有的派生类中该函数都是virtual，而不需要再显式地声明为virtual)
2. 压制多态可以使用域操作符来实现
```c++
class Base{
public:
    virtual void f1(){
        cout<<"base:f1()";
    }
};
class Derive:public Base{
public:
    void f1(){
        cout<<"derive:f1()";
    }
};
int main(){
   Derive* bp=new Derive();
   bp->Base::f1();//base:f1()
   bp->f1();//derive:f1()
   return 0;
}
```
1. 多继承情况下，派生类中有多个虚函数表，虚函数的排列方式和继承的顺序一致。派生类重写函数将会覆盖所有虚函数表的同名内容，**派生类自定义新的虚函数将会在第一个类（按照派生类的继承顺序，而不是成员初始化列表中的顺序）的虚函数表的后面进行扩充。** [C++继承中构造顺序](https://blog.csdn.net/tangjienihaoma/article/details/84526995)