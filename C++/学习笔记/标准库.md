# 标准库
## 容器库概览
所有容器均提供以下操作：
![](image/2023-03-26-11-51-21.png)
![](image/2023-03-26-11-51-42.png)
### 容器定义和初始化
![](image/2023-03-26-11-53-04.png)
为了创建一个容器为另一个容器的拷贝，两个容器的类型及其元素类型必须匹配。不过， 当传递迭代器参数来拷贝一个范围时，就不要求容器类型是相同的了。而且，新容器和原容器中的元素类型也可以不同，只要能将要拷贝的元素转换为要初始化的容器的元素类型即可。
#### array具有固定大小
与内置数组一样， 标准库array的大小也是类型的一部分。当定义一个array时，除了指定元素类型，还要指定容器大小。
```cpp
array<int,5> a1{1,2,3,4,5};
array<int,5> a2=a1;
array<int,5> a1{1,2,3,4};
 ```
array 大小固定的特性也影响了它所定义的构造函数的行为。与其他容器不同，一个默认构造的array是非空的：它包含了与其大小一样多的元素。这些元素都被默认初始化。

如果我们对array进行列表初始化，初始值的数目必须等于或小于array的大小。如果初始值数目小于array的大小，则它们被用来初始化array中靠前的元素，所有剩余元素都会进行值初始化。在这两种情况下，如果元素类型是一个类类型，那么该类必须有一个默认构造函数，以使值初始化能够进行。

### 赋值和swap
下中列出的与赋值相关的运算符可用于所有容器，赋值运算符将其左边容器中的全部元素替换为右边容器中元素的拷贝。

与内置数组不同，标准库array类型允许赋值。赋值号左右两边的运算对象必须具有相同的类型。由于右边运算对象的大小可能与左边运算对象的大小不同，因此**array类型不支持assign**, 也不允许用花括号包围的值列表进行赋值。

![](image/2023-03-26-12-22-41.png)

#### assign
由于旧元素被替换，因此传递给assign的迭代器不能指向调用assign的容器。
#### swap 
除array外，swap不对任何元素进行拷贝、删除或插入操作，因此可以保证在常数时间内完成。
除string外，指向容器的迭代器、引用和指针在swap操作之后都不会失效。

## 顺序容器

### 概览
![](image/2023-03-26-13-37-18.png)
### 添加元素
![](image/2023-03-26-13-03-29.png)

emplace函数在容器中直接构造元素。传递给emplace函数的参数必须与元素类型的构造函数相匹配。
### 访问元素
![](image/2023-03-26-15-02-52.png)
### 删除元素
![](image/2023-03-26-15-14-33.png)
### `forward_list`
![](image/2023-03-26-16-54-17.png)
### 改变容器大小
![](image/2023-03-26-17-53-03.png)
### 容器操作可能导致迭代器失效
![](image/2023-03-26-17-51-39.png)

### vector是如何增长的
![](image/2023-03-26-18-14-14.png)

capacity操作告诉我们容器在不扩张内存空间的情况下可以容纳多少个元素。
reserve操作允许我们通知容器它应该准备保存多少个元素。reserve并不改变容器中元素的数量，它仅影响vector预先分配多大的内存空间。

只有当需要的内存空间超过当前容量时，reserve调用才会改变vector的容量。如果需求大小大于当前容量，reserve至少分配与需求一样大的内存空间（可能更大）。调用reserve永远也不会减少容器占用的内存空间。
类似的，resize成员函数只改变容器中元素的数目，而不是容器的容量。我们不能使用resize来减少容器预留的内存空间。

每个vector实现都可以选择自己的内存分配策略。但是必须遵守的一条原则是：**只有当迫不得已时才可以分配新的内存空间。**

### 额外的string操作
#### 构造string的其他方法
![](image/2023-03-26-19-07-25.png)
![](image/2023-03-26-20-38-07.png)
通常当我们从一个const char*创建string时，指针指向的数组必须以空字符结尾，拷贝操作遇到空字符时停止。如果我们还传递给构造函数一个计数值，数组就不必空字符结尾。如果我们未传递计数值且数组也未以空字符结尾，或者给定计数值大于数组大小，则构造函数的行为是未定义的。
#### 改变string的其他方法
![](image/2023-03-26-20-44-09.png)
![](image/2023-03-26-20-44-25.png)

#### string搜索操作
![](image/2023-03-26-21-35-06.png)
![](image/2023-03-26-21-35-25.png)
#### compare操作
![](image/2023-03-26-21-36-06.png)
#### 数值转换
![](image/2023-03-26-21-53-04.png)

### 容器适配器
![](image/2023-03-26-22-26-50.png)
#### 栈适配器
![](image/2023-03-26-22-25-34.png)
#### 队列适配器
![](image/2023-03-26-22-25-57.png)
![](image/2023-03-26-22-26-17.png)
## 关联容器


## 动态内存

### allocator类
allocator类定义在memory中，它将内存分配与对象构造分离开。它提供一种类型感知的内存分配方法，它分配的内存是原始的、未构造的。

为了使用allocate类返回的内存，必须用construct构造对象。只能对真正构造了的元素进行destroy操作。
![](image/IMG_1009.PNG)
![](image/IMG_1010.PNG)