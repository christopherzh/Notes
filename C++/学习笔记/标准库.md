# 标准库
## 容器库概览
所有容器均提供以下操作：
![](image/2023-03-26-11-51-21.png)
![](image/2023-03-26-11-51-42.png)
### 容器定义和初始化
![](image/2023-03-26-11-53-04.png)
为了创建一个容器为另一个容器的拷贝，两个容器的类型及其元素类型必须匹配。不过， 当传递迭代器参数来拷贝一个范围时，就不要求容器类型是相同的了。而且，新容器和原容器中的元素类型也可以不同，只要能将要拷贝的元素转换为要初始化的容器的元素类型即可。
#### array具有固定大小
与内置数组一样， 标准库array的大小也是类型的一部分。当定义一个array时，除了指定元素类型，还要指定容器大小。
```cpp
array<int,5> a1{1,2,3,4,5};
array<int,5> a2=a1;
array<int,5> a1{1,2,3,4};
 ```
array 大小固定的特性也影响了它所定义的构造函数的行为。与其他容器不同，一个默认构造的array是非空的：它包含了与其大小一样多的元素。这些元素都被默认初始化。

如果我们对array进行列表初始化，初始值的数目必须等于或小于array的大小。如果初始值数目小于array的大小，则它们被用来初始化array中靠前的元素，所有剩余元素都会进行值初始化。在这两种情况下，如果元素类型是一个类类型，那么该类必须有一个默认构造函数，以使值初始化能够进行。

### 赋值和swap
下中列出的与赋值相关的运算符可用于所有容器，赋值运算符将其左边容器中的全部元素替换为右边容器中元素的拷贝。

与内置数组不同，标准库array类型允许赋值。赋值号左右两边的运算对象必须具有相同的类型。由于右边运算对象的大小可能与左边运算对象的大小不同，因此**array类型不支持assign**, 也不允许用花括号包围的值列表进行赋值。

![](image/2023-03-26-12-22-41.png)

#### assign
由于旧元素被替换，因此传递给assign的迭代器不能指向调用assign的容器。
#### swap 
除array外，swap不对任何元素进行拷贝、删除或插入操作，因此可以保证在常数时间内完成。
除string外，指向容器的迭代器、引用和指针在swap操作之后都不会失效。

## 顺序容器

### 概览
![](image/2023-03-26-13-37-18.png)
### 添加元素
![](image/2023-03-26-13-03-29.png)

emplace函数在容器中直接构造元素。传递给emplace函数的参数必须与元素类型的构造函数相匹配。
### 访问元素
![](image/2023-03-26-15-02-52.png)
### 删除元素
![](image/2023-03-26-15-14-33.png)
### `forward_list`
![](image/2023-03-26-16-54-17.png)
### 改变容器大小
![](image/2023-03-26-17-53-03.png)
### 容器操作可能导致迭代器失效
![](image/2023-03-26-17-51-39.png)

### vector是如何增长的
![](image/2023-03-26-18-14-14.png)

capacity操作告诉我们容器在不扩张内存空间的情况下可以容纳多少个元素。
reserve操作允许我们通知容器它应该准备保存多少个元素。reserve并不改变容器中元素的数量，它仅影响vector预先分配多大的内存空间。

只有当需要的内存空间超过当前容量时，reserve调用才会改变vector的容量。如果需求大小大于当前容量，reserve至少分配与需求一样大的内存空间（可能更大）。调用reserve永远也不会减少容器占用的内存空间。
类似的，resize成员函数只改变容器中元素的数目，而不是容器的容量。我们不能使用resize来减少容器预留的内存空间。

每个vector实现都可以选择自己的内存分配策略。但是必须遵守的一条原则是：**只有当迫不得已时才可以分配新的内存空间。**

### 额外的string操作
#### 构造string的其他方法
![](image/2023-03-26-19-07-25.png)
![](image/2023-03-26-20-38-07.png)
通常当我们从一个const char*创建string时，指针指向的数组必须以空字符结尾，拷贝操作遇到空字符时停止。如果我们还传递给构造函数一个计数值，数组就不必空字符结尾。如果我们未传递计数值且数组也未以空字符结尾，或者给定计数值大于数组大小，则构造函数的行为是未定义的。
#### 改变string的其他方法
![](image/2023-03-26-20-44-09.png)
![](image/2023-03-26-20-44-25.png)

#### string搜索操作
![](image/2023-03-26-21-35-06.png)
![](image/2023-03-26-21-35-25.png)
#### compare操作
![](image/2023-03-26-21-36-06.png)
#### 数值转换
![](image/2023-03-26-21-53-04.png)

### 容器适配器
![](image/2023-03-26-22-26-50.png)
#### 栈适配器
![](image/2023-03-26-22-25-34.png)
#### 队列适配器
![](image/2023-03-26-22-25-57.png)
![](image/2023-03-26-22-26-17.png)


## 关联容器
![](image/2023-03-30-17-28-00.png)

### pair类型
pair类型定义在头文件`utility`中。一个pair保存两个数据成员，创建pair时必须提供两个类型名，两个类型不要求一样。

pair的默认构造函数对数据成员进行值初始化。我们可以为每个成员提供初始化器。
```cpp
pair<string,int> p1;
pair<string,int> p2{"a",1};
 ```
![](image/2023-03-30-18-15-11.png)

```cpp
// 三种创建pair的方式
pair<string, int> fun(int i)
{
    if (i == 1)
        return {"a", 1};
    if (i == 2)
        return pair<string, int>{"b", 2};
    if (i == 3)
        return make_pair("c", 3);
}
 ```

### 关联容器的类型别名
![](image/2023-03-30-19-04-17.png)
### 关联容器迭代器
当解引用一个关联容器迭代器时，我们会得到一个类型为容器的`value_type`的值
的引用。对map而言，value type是一个pair类型，其**first成员保存const的
关键字**，second成员保存值。我们可以改变pair的值，但是不能改变关键字成员的值。

虽然set类型同时定义了`iterator`和`const_iterator`类型，但两种类型都只允许只读访问set中的元素。与不能改变一个map元素的关键字一样，**一个set中的关键字也是const的**。可以用一个set迭代器来读取元素的值，但不能修改。

关键字是const这一特性意味着不能将关联容器传递给修改或重排容器元素的算法，因为这类算法需要向元素写入值，而set类型中的元素是const的，map的元素是pair，其第一个成员是const的。

### 添加元素
![](image/2023-03-30-21-34-57.png)

### 删除元素
![](image/2023-03-30-21-36-36.png)

### 访问元素
![](image/2023-03-30-21-36-57.png)
![](image/2023-03-30-21-58-55.png)

**第二张图纠错：`c.equal_range(k)`：若未找到匹配元素，则pair的两个迭代器类型的成员均指向关键字可以插入的位置。**

## 无序容器
无序关联容器使用哈希函数和关键字类型的==运算符来组织元素。

![](image/2023-03-30-22-12-32.png)

