# Linux
## Shell
### `!`的使用
https://www.cnblogs.com/yy3b2007com/p/11267237.html
https://blog.csdn.net/donggua_fu/article/details/77387748 (好像不对)

## 链接
[有关链接的博客讲解](http://c.biancheng.net/linux/ln.html)
- 硬链接： 与普通文件没什么不同，inode都指向同一个文件在硬盘中的区块
- 软链接： 保存了其代表的文件的绝对路径，是另外一种文件，在硬盘上有独立的区块，访问时替换自身路径。类似于windows的快捷方式。
### 为什么 ln 不允许硬链接到目录
Linux 系统中的硬链接有两个限制：
1. 不能跨越文件系统。
2. 不允许普通用户对目录作硬链接。

至于第一个限制，很好理解，而第二个就不那么好理解了。

我们对任何一个目录用 ls-l 命令都可以看到其链接数至少是 2，这也说明了系统中是存在基于目录的硬链接的，而且命令 ln -d（-d选项表示针对目录建立硬链接）也允许 root 用户尝试对目录作硬链接。这些都说明了系统限制对目录进行硬链接只是一个硬性规定，并不是逻辑上不允许或技术上不可行。那么操作系统为什么要进行这个限制呢？

这是因为，如果引入了对目录的硬连接就有可能在目录中引入循环链接，那么在目录遍历的时候系统就会陷入无限循环当中。也许有人会说，符号连接不也可以引入循环链接吗，那么为什么不限制目录的符号连接呢？

原因就在于，在 Linux 系统中，每个文件（目录也是文件）都对应着一个 inode 结构，其中 inode 数据结构中包含了文件类型（目录、普通文件、符号连接文件等）的信息，也就是说，操作系统在遍历目录时可以判断出其是否是符号连接。既然可以判断出它是否是符号连接，当然就可以采取一些措施来防范进入过大过深的循环层次，于是大部分系统会规定在连续遇到 8 个符号连接后就停止遍历。但是对于硬链接，由于操作系统中采用的数据结构和算法限制，目前是不能防范这种死循环的。

基于这样的考虑，系统不允许普通用户建立目录硬链接。
   
# 计算机网络
## TCP
### 序号
1. 单纯的ACK报文段不消耗序号，即TCP头部的seq仍为上一次发送的TCP报文段seq。但通常TCP在接收到数据时并不立即发送ACK；相反，它推迟发送，以便将ACK与需要沿该方向发送的数据一起发送（有时称这种现象为数据捎带ACK）。
2. 即使**发送方**的同步(ACK=1)和结束(FIN=1)报文段不携带任何数据，它们也要占用一个序号值，即它们应收到的ack确认号为seq+1(seq为**发送方**的同步或结束报文的序号值)。
3. 消耗一个序列号意味着使用重传进行可靠传输，因此不消耗ACK序列号的ACK则不是。
4. 序号值是对应用层传来的程序数据的字节流进行编号，传输过程中产生的TCP头部不需要编号。


### 拥塞控制
1. 快重传过程中，当收到三个重复的确认报文时，计算`ssthresh后`，`cwnd=ssthresh+3*MSS` (Maximum Segment Size ，TCP提交给IP层最大分段大小，不包含TCP Header和 TCP Option，只包含TCP Payload)，之所以`+3*MSS`，是因为发送方已经收到三个重复的ACK确认报文，表明有3个“老”的数据包离开了网络。
2. 快恢复时，当收到新的数据包的ACK时，把`cwnd`设置为第一步中的`ssthresh`的值，原因是因为该ACK确认了新的数据，说明从重复ACK时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态。
3. 快速恢复的思想是“数据包守恒”原则，即同一个时刻在网络中的数据包数量是恒定的，只有当“老”数据包离开了网络后，才能向网络中发送一个“新”的数据包，如果发送方收到一个重复的ACK，那么根据TCP的ACK机制就表明有一个数据包离开了网络，于是`cwnd`加1。


## JWT鉴权
[JWT&对称加密&非对称加密](https://blog.csdn.net/weixin_45139342/article/details/104599151)

