# 八股文速记
## 数据库
### 数据库基础知识
#### 什么是范式
1NF：属性不可再分。
2NF：1NF的基础之上，消除了非主属性对于码（候选码与主码）的部分函数依赖。 即，它要求关系表中的非主键列必须完全依赖于关系表的候选键（主键），而不能部分依赖于候选键。
3NF：3NF在2NF的基础之上，消除了非主属性对于码（候选码与主码）的传递函数依赖。即，它要求一个关系表中的非主键列必须直接依赖于候选键（主键），而不能依赖于其他非主键列。换句话说，非主键列之间不能相互依赖。
### MySQL字段类型
1. CHAR是定长字符串，VARCHAR是变长字符串。CHAR在存储时会在右边填充空格以达到指定的长度，检索时会去掉空格；VARCHAR在存储时需要使用1或2个额外字节记录字符串的长度，检索时不需要处理。
2. DECIMAL的内存占用：每4个字节存9个数字，小数点本身占1个字节。
3. DECIMAL(10,6)表示小数点左边4位（整数部分）和小数点右边6位。
### MySQL事务
1. 事务的四个特性（ACID）：原子性、一致性、隔离性、持久性
#### 并发事务可能引发的问题
严重排序由高到低：
1. 脏读：读到其他事务未提交的数据
2. 不可重复读：前后读取的数据不一致
3. 幻读：前后读取的记录数量不一致
#### 隔离级别
隔离水平由低到高分别是：
- **读未提交（read uncommitted）**：指一个事务还没提交时，它做的变更就能被其他事务看到；
- **读提交（read committed）**：指一个事务提交之后，它做的变更才能被其他事务看到；
- **可重复读（repeatable read）**：指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，MySQL InnoDB引擎的默认隔离级别；
- **串行化（serializable）**：会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；

在「读未提交」隔离级别下，可能发生**脏读、不可重复读和幻读**现象；
在「读提交」隔离级别下，可能发生**不可重复读和幻读**现象，但是不可能发生脏读现象；
在「可重复读」隔离级别下，可能发生**幻读**现象，但是不可能脏读和不可重复读现象；
在「串行化」隔离级别下，脏读、不可重复读和幻读现象都不可能会发生。

实现方式：
对于「读未提交」隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了；
对于「串行化」隔离级别的事务来说，通过加读写锁的方式来避免并行访问；
对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 Read View 来实现的，它们的区别在于创建 Read View 的时机不同，大家可以把 Read View 理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。「读提交」隔离级别是在「每个语句执行前」都会重新生成一个 Read View，而「可重复读」隔离级别是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View。
#### MySQL的默认隔离级别
MySQL 在「**可重复读**」隔离级别下，可以很大程度上避免幻读现象的发生（注意是很大程度避免，并不是彻底避免），所以 MySQL 并不会使用「串行化」隔离级别来避免幻读现象的发生，因为使用「串行化」隔离级别会影响性能。

MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了，详见这篇文章 (opens new window)），解决的方案有两种：

针对快照读（普通 select 语句），是通过 MVCC 方式解决了幻读，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。
针对当前读（select ... for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读，因为当执行 select ... for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。
## 数据结构与算法
### 二叉树
#### 最优二叉树（哈夫曼树）
在构建最优二叉树时，n个叶子的哈夫曼树要经过n-1次合并，产生n-1个新结点。因此最终求得的哈夫曼树中共有2n-1个结点。

e.g. 给定一个最优二叉树中的节点总数为123，我们可以通过以下计算来确定叶子节点的个数：
叶子节点个数 = （节点总数 + 1）/ 2
将节点总数替换为123，我们有：
叶子节点个数 = （123 + 1）/ 2 = 62
所以，这棵最优二叉树中有62个叶子节点。
## 杂类
### 200G的字符串中有一对相同的字符串，如何用一台内存为200M的机器来进行查询？
答：使用哈希桶，共1024个桶

