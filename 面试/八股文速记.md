# 八股文速记
## 数据库
### 数据库基础知识
#### 什么是范式
1NF：属性不可再分。
2NF：1NF的基础之上，消除了非主属性对于码（候选码与主码）的部分函数依赖。 即，它要求关系表中的非主键列必须完全依赖于关系表的候选键（主键），而不能部分依赖于候选键。
3NF：3NF在2NF的基础之上，消除了非主属性对于码（候选码与主码）的传递函数依赖。即，它要求一个关系表中的非主键列必须直接依赖于候选键（主键），而不能依赖于其他非主键列。换句话说，非主键列之间不能相互依赖。
### MySQL字段类型
1. CHAR是定长字符串，VARCHAR是变长字符串。CHAR在存储时会在右边填充空格以达到指定的长度，检索时会去掉空格；VARCHAR在存储时需要使用1或2个额外字节记录字符串的长度，检索时不需要处理（变长字段允许存储的最大字节数小于等于255字节时为1字节，大于255字节时为2字节）。
2. DECIMAL的内存占用：每4个字节存9个数字，小数点本身占1个字节。
3. DECIMAL(10,6)表示小数点左边4位（整数部分）和小数点右边6位。

### MySQL索引
#### B+树
B+Tree 是一种多叉树，叶子节点才存放数据，非叶子节点只存放索引，而且每个节点里的数据是按主键顺序存放的。每一层父节点的索引值都会出现在下层子节点的索引值中，因此在叶子节点中，包括了所有的索引值信息，并且每一个叶子节点都有两个指针，分别指向下一个叶子节点和上一个叶子节点，形成一个双向链表。

B+Tree 存储千万级的数据只需要 3-4 层高度就可以满足，这意味着从千万级的表查询目标数据最多需要 3-4 次磁盘 I/O，所以B+Tree 相比于 B 树和二叉树来说，最大的优势在于查询效率很高，因为即使在数据量很大的情况，查询一个数据的磁盘 I/O 依然维持在 3-4次。
#### 为什么 MySQL 采用 B+ 树作为索引？
MySQL 是会将数据持久化在硬盘，而存储功能是由 MySQL 存储引擎实现的，所以讨论 MySQL 使用哪种数据结构作为索引，实际上是在讨论存储引使用哪种数据结构作为索引，InnoDB 是 MySQL 默认的存储引擎，它就是采用了 B+ 树作为索引的数据结构。

要设计一个 MySQL 的索引数据结构，不仅仅考虑数据结构增删改的时间复杂度，更重要的是要考虑磁盘 I/0 的操作次数。因为索引和记录都是存放在硬盘，硬盘是一个非常慢的存储设备，我们在查询数据的时候，最好能在尽可能少的磁盘 I/0 的操作次数内完成。

>二分查找树虽然是一个天然的二分结构，能很好的利用二分查找快速定位数据，但是它存在一种极端的情况，每当插入的元素都是树内最大的元素，就会导致二分查找树退化成一个链表，此时查询复杂度就会从 O(logn)降低为 O(n)。

>为了解决二分查找树退化成链表的问题，就出现了自平衡二叉树，保证了查询操作的时间复杂度就会一直维持在 O(logn) 。但是它本质上还是一个二叉树，每个节点只能有 2 个子节点，随着元素的增多，树的高度会越来越高。
而树的高度决定于磁盘 I/O 操作的次数，因为树是存储在磁盘中的，访问每个节点，都对应一次磁盘 I/O 操作，也就是说树的高度就等于每次查询数据时磁盘 IO 操作的次数，所以树的高度越高，就会影响查询性能。

>B 树和 B+ 都是通过多叉树的方式，会将树的高度变矮，所以这两个数据结构非常适合检索存于磁盘中的数据。

但是 MySQL 默认的存储引擎 InnoDB 采用的是 B+ 作为索引的数据结构，原因有：

- B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比存储即存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I/O次数会更少。
- B+ 树有大量的冗余节点（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树在插入、删除的效率都更高，比如删除根节点的时候，不会像 B 树那样会发生复杂的树的变化；
- B+ 树叶子节点之间用链表连接了起来，有利于范围查询，而 B 树要实现范围查询，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I/O 操作，范围查询效率不如 B+ 树。

#### 从数据页的角度看 B+ 树
[InnoDB是如何存储数据的？](https://xiaolincoding.com/mysql/index/page.html#innodb-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E7%9A%84)



#### 索引的分类
我们可以按照四个角度来分类索引。

- 按「数据结构」分类：B+tree索引、Hash索引、Full-text索引。
- 按「物理存储」分类：聚簇索引（主键索引）、二级索引（辅助索引）。
- 按「字段特性」分类：主键索引、唯一索引、普通索引、前缀索引。
- 按「字段个数」分类：单列索引、联合索引。
##### 按物理存储
从物理存储的角度来看，索引分为聚簇索引（主键索引）、二级索引（辅助索引）。

在创建表时，InnoDB 存储引擎会根据不同的场景选择不同的列作为索引：
- 如果有主键，默认会使用主键作为聚簇索引的索引键（key）；
- 如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键（key）；
- 在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键（key）；

其它索引都属于辅助索引（Secondary Index），也被称为二级索引或非聚簇索引。创建的主键索引和二级索引默认使用的是 B+Tree 索引。
- 主键索引的 B+Tree 的叶子节点存放的是**实际数据**，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；
- 二级索引的 B+Tree 的叶子节点存放的是**主键值**，而不是实际数据。
  
所以，在查询时使用了二级索引，如果查询的数据能在二级索引里查询的到，那么就不需要回表，这个过程就是**覆盖索引**（e.g. 利用二级索引查询主键值）。
如果查询的数据不在二级索引里，就会先检索二级索引，找到对应的叶子节点，获取到主键值后，然后再检索主键索引，就能查询到数据了，这个过程就是**回表**。


##### 按字段特性
###### 主键索引
主键索引就是建立在主键字段上的索引，通常在创建表的时候一起创建，一张表最多只有一个主键索引，索引列的值不允许有空值。

在创建表时，创建主键索引的方式如下：
```sql
CREATE TABLE table_name  (
  ....
  PRIMARY KEY (index_column_1) USING BTREE
);
```
###### 唯一索引
唯一索引建立在 UNIQUE 字段上的索引，一张表可以有多个唯一索引，索引列的值必须唯一，但是允许有空值。

在创建表时，创建唯一索引的方式如下：
```sql
CREATE TABLE table_name  (
  ....
  UNIQUE KEY(index_column_1,index_column_2,...) 
);
```
建表后，如果要创建唯一索引，可以使用这面这条命令：
```sql
CREATE UNIQUE INDEX index_name
ON table_name(index_column_1,index_column_2,...); 
```
###### 普通索引
普通索引就是建立在普通字段上的索引，既不要求字段为主键，也不要求字段为 UNIQUE。

在创建表时，创建普通索引的方式如下：
```sql
CREATE TABLE table_name  (
  ....
  INDEX(index_column_1,index_column_2,...) 
);
```
建表后，如果要创建普通索引，可以使用这面这条命令：
```sql
CREATE INDEX index_name
ON table_name(index_column_1,index_column_2,...); 
```
###### 前缀索引
前缀索引是指对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为 `char、varchar、binary、varbinary` 的列上。

使用前缀索引的目的是为了减少索引占用的存储空间，提升查询效率。

在创建表时，创建前缀索引的方式如下：
```sql
CREATE TABLE table_name(
    column_list,
    INDEX(column_name(length))
); 
```
建表后，如果要创建前缀索引，可以使用这面这条命令：
```sql
CREATE INDEX index_name
ON table_name(column_name(length)); 
```
##### 按字段个数
从字段个数的角度来看，索引分为单列索引、联合索引（复合索引）。
- 建立在单列上的索引称为单列索引，比如主键索引；
- 建立在多列上的索引称为联合索引；

###### 联合索引
通过将多个字段组合成一个索引，该索引就被称为联合索引。

使用联合索引时，存在**最左匹配原则**，也就是按照最左优先的方式进行索引的匹配。在使用联合索引进行查询的时候，如果不遵循「最左匹配原则」，联合索引会失效，这样就无法利用到索引快速查询的特性了。

联合索引的最左匹配原则，在遇到范围查询（如 >、<）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。注意，对于 >=、<=、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配。详见[联合索引的最左匹配详解](https://xiaolincoding.com/mysql/index/index_interview.html#%E6%8C%89%E5%AD%97%E6%AE%B5%E4%B8%AA%E6%95%B0%E5%88%86%E7%B1%BB)

#### 何时应该建立索引？
##### 什么时候适用索引？
- 字段有唯一性限制的，比如商品编码；
- 经常用于 WHERE 查询条件的字段，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。
- 经常用于 GROUP BY 和 ORDER BY 的字段，这样在查询的时候就不需要再去做一次排序了，因为我们都已经知道了建立索引之后在 B+Tree 中的记录都是排序好的。
##### 什么时候不需要创建索引？
- WHERE 条件，GROUP BY，ORDER BY 里用不到的字段，索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的，因为索引是会占用物理空间的。
- 字段中存在大量重复数据，不需要创建索引，比如性别字段，只有男女，如果数据库表中，男女的记录分布均匀，那么无论搜索哪个值都可能得到一半的数据。
- 经常更新的字段不用创建索引，比如不要对电商项目的用户余额建立索引，因为索引字段频繁修改，由于要维护B+Tree的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的。
#### 优化索引的方法
几种常见优化索引的方法：
- 前缀索引优化
- 覆盖索引优化
- 主键索引最好是自增的
- 索引最好设置为NOT NULL
- 防止索引失效
#### 索引失效的情况
1. 当我们使用左或者左右模糊匹配的时候，也就是 like %xx 或者 like %xx%这两种方式都会造成索引失效；
2. 当我们在查询条件中对索引列使用函数，就会导致索引失效。
3. 当我们在查询条件中对索引列进行表达式计算，也是无法走索引的。
4. MySQL在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。如果字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会发生隐式类型转换，由于隐式类型转换是通过 CAST 函数实现的，等同于对索引列使用了函数，所以就会导致索引失效。
5. 联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。
6. 在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。


### MySQL事务
1. 事务的四个特性（ACID）：原子性、一致性、隔离性、持久性
#### 并发事务可能引发的问题
严重排序由高到低：
1. 脏读：读到其他事务未提交的数据
2. 不可重复读：前后读取的数据不一致
3. 幻读：前后读取的记录数量不一致
#### 隔离级别
隔离水平由低到高分别是：
- **读取未提交（read-uncommitted）**：指一个事务还没提交时，它做的变更就能被其他事务看到；
- **读取已提交（read-committed）**：指一个事务提交之后，它做的变更才能被其他事务看到；
- **可重复读（repeatable-read）**：指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，MySQL InnoDB引擎的默认隔离级别；
- **可串行化（serializable）**：会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；

在「读未提交」隔离级别下，可能发生**脏读、不可重复读和幻读**现象；
在「读提交」隔离级别下，可能发生**不可重复读和幻读**现象，但是不可能发生脏读现象；
在「可重复读」隔离级别下，可能发生**幻读**现象，但是不可能脏读和不可重复读现象；
在「串行化」隔离级别下，脏读、不可重复读和幻读现象都不可能会发生。

**实现方式：**
对于「读未提交」隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了；
对于「串行化」隔离级别的事务来说，通过加读写锁的方式来避免并行访问；
对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 Read View 来实现的，它们的区别在于创建 Read View 的时机不同，大家可以把 Read View 理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。「读提交」隔离级别是在「**每个语句执行前**」都会重新生成一个 Read View，而「可重复读」隔离级别是「**启动事务时**」生成一个 Read View，然后整个事务期间都在用这个 Read View。
#### MySQL的默认隔离级别
MySQL 在「**可重复读**」隔离级别下，可以很大程度上避免幻读现象的发生（注意是很大程度避免，并不是彻底避免），所以 MySQL 并不会使用「串行化」隔离级别来避免幻读现象的发生，因为使用「串行化」隔离级别会影响性能。

MySQL InnoDB引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了，），解决的方案有两种：

针对快照读（普通 select 语句），是通过 MVCC 方式解决了幻读，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。
针对当前读（select ... for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读，因为当执行 select ... for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。

#### 可重复读隔离级别下，两个发生幻读场景的例子

>第一个例子：对于快照读， MVCC 并不能完全避免幻读现象。因为当事务 A 更新了一条事务 B 插入的记录，那么事务 A 前后两次查询的记录条目就不一样了，所以就发生幻读。

>第二个例子：对于当前读，如果事务开启后，并没有执行当前读，而是先快照读，然后这期间如果其他事务插入了一条记录，那么事务后续使用当前读进行查询的时候，就会发现两次查询的记录条目就不一样了，所以就发生幻读。

所以，MySQL 可重复读隔离级别并没有彻底解决幻读，只是很大程度上避免了幻读现象的发生。

要避免这类特殊场景下发生幻读的现象的话，就是尽量在开启事务之后，马上执行 select ... for update 这类当前读的语句，因为它会对记录加 next-key lock，从而避免其他事务插入一条新记录。
#### Read View在MVCC是如何工作的
[Read View 在 MVCC 里如何工作的？](
https://xiaolincoding.com/mysql/transaction/mvcc.html#read-view-%E5%9C%A8-mvcc-%E9%87%8C%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84)
#### 当前读与快照读
[当前读与快照读的区别](https://javaguide.cn/database/mysql/mysql-questions-01.html#%E5%BD%93%E5%89%8D%E8%AF%BB%E5%92%8C%E5%BF%AB%E7%85%A7%E8%AF%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB)
### MySQL锁
#### 全局锁
要使用全局锁，则要执行这条命令：
```sql
flush tables with read lock
```

执行后，**整个数据库**就处于**只读状态**了，这时其他线程执行以下操作，都会被阻塞：
- 对数据的增删改操作，比如 insert、delete、update等语句；
- 对表结构的更改操作，比如 alter table、drop table 等语句。
  
如果要释放全局锁，则要执行这条命令：
```sql
unlock tables
```

当然，当会话断开了，全局锁会被自动释放。

##### 全局锁应用场景
全局锁主要应用于做全库逻辑备份，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。
##### 如何避免全局锁备份所导致的只能读数据库表情况：
如果数据库的引擎支持的事务支持可重复读的隔离级别，那么在备份数据库之前先开启事务，会先创建 Read View，然后整个事务执行期间都在用这个 Read View，而且由于 MVCC 的支持，备份期间业务依然可以对数据进行更新操作。
#### 表级锁
MySQL 里面表级别的锁有这几种：
1. [表锁](https://xiaolincoding.com/mysql/lock/mysql_lock.html#%E8%A1%A8%E9%94%81)
2. [元数据锁（MDL）](https://xiaolincoding.com/mysql/lock/mysql_lock.html#%E5%85%83%E6%95%B0%E6%8D%AE%E9%94%81)
3. 意向锁
4. AUTO-INC锁
##### 意向锁
意向锁是表级锁，共有两种：
1. 意向共享锁（Intention Shared Lock，IS 锁）：事务有意向对表中的某些记录加共享锁（S 锁），加共享锁前必须先取得该表的 IS 锁。
2. 意向排他锁（Intention Exclusive Lock，IX 锁）：事务有意向对表中的某些记录加排他锁（X 锁），加排他锁之前必须先取得该表的 IX 锁。

也就是，当执行**插入、更新、删除**操作，需要先对表加上「意向独占锁」，然后对该记录加独占锁。

而普通的 select 是不会加行级锁的，普通的 select 语句是利用 MVCC 实现一致性读，是无锁的。

不过，select 也是可以对记录加共享锁和独占锁的，具体方式如下：
```sql
//先在表上加上意向共享锁，然后对读取的记录加共享锁
select ... lock in share mode;

//先表上加上意向独占锁，然后对读取的记录加独占锁
select ... for update;
```

意向共享锁和意向独占锁是表级锁，**不会和行级**的共享锁和独占锁发生冲突，而且**意向锁之间也不会**发生冲突，**只会和**共享表锁`lock tables ... read`和独占表锁`lock tables ... write`发生冲突。

表锁和行锁之间是满足读读共享、读写互斥、写写互斥的。

![](image/2023-10-12-14-40-36.png)

#### 行级锁
InnoDB的行锁是针对**索引字段**加的锁，表级锁是针对**非索引字段**加的锁。当我们执行`UPDATE、DELETE`语句时，如果`WHERE`条件中字段没有命中唯一索引或者索引失效的话，就会导致扫描全表对表中的所有行记录进行加锁。

行级锁的类型主要有三类：
1. Record Lock，记录锁，也就是仅仅把一条记录锁上；
2. Gap Lock，间隙锁，锁定一个范围，但是不包含记录本身；
3. Next-Key Lock：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。
##### Record Lock 
Record Lock 称为记录锁，锁住的是一条记录。而且记录锁是有 S 锁和 X 锁之分的：
- 当一个事务对一条记录加了 S 型记录锁后，其他事务也可以继续对该记录加 S 型记录锁（S 型与 S 锁兼容），但是不可以对该记录加 X 型记录锁（S 型与 X 锁不兼容）;
- 当一个事务对一条记录加了 X 型记录锁后，其他事务既不可以对该记录加 S 型记录锁（S 型与 X 锁不兼容），也不可以对该记录加 X 型记录锁（X 型与 X 锁不兼容）。
##### Gap Lock
Gap Lock 称为间隙锁，只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象。

>假设，表中有一个范围 id 为（3，5）间隙锁，那么其他事务就无法插入 id = 4 这条记录了，这样就有效的防止幻读现象的发生。

间隙锁虽然存在 X 型间隙锁和 S 型间隙锁，但是并没有什么区别，**间隙锁之间是兼容的**，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的。
##### Next-Key Lock
Next-Key Lock 称为临键锁，是 Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。

>假设，表中有一个范围 id 为（3，5] 的 next-key lock，那么其他事务即不能插入 id = 4 记录，也不能修改 id = 5 这条记录。

所以，next-key lock 即能保护该记录，又能阻止其他事务将新纪录插入到被保护记录前面的间隙中。

next-key lock 是包含间隙锁+记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的。
##### 插入意向锁
一个事务在**插入**一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁（next-key lock 也包含间隙锁）。
>[对于insert语句是如何加行级锁的，请点开链接查看](https://xiaolincoding.com/mysql/lock/deadlock.html#insert-%E8%AF%AD%E5%8F%A5%E6%98%AF%E6%80%8E%E4%B9%88%E5%8A%A0%E8%A1%8C%E7%BA%A7%E9%94%81%E7%9A%84)

如果有的话，插入操作就会发生阻塞，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻），在此期间会生成一个插入意向锁，表明有事务想在某个区间插入新记录，但是现在处于等待状态。

>MySQL 加锁时，是先生成锁结构，然后设置锁的状态，如果锁状态是等待状态，并不是意味着事务成功获取到了锁，只有当锁状态为正常状态时，才代表事务成功获取到了锁。

插入意向锁名字虽然有意向锁，但是它并不是意向锁，**它是一种特殊的间隙锁，属于行级别锁。**

如果说间隙锁锁住的是一个区间，那么「插入意向锁」锁住的就是一个点。因而从这个角度来说，插入意向锁确实是一种特殊的间隙锁。

插入意向锁与间隙锁的另一个非常重要的差别是：尽管「插入意向锁」也属于间隙锁，但**两个事务却不能在同一时间内，一个拥有间隙锁，另一个拥有该间隙区间内的插入意向锁**（当然，插入意向锁如果不在间隙锁区间内则是可以的）。
#### 行级锁是如何添加的
[MySQL是怎么加行级锁的？](https://xiaolincoding.com/mysql/lock/how_to_lock.html#mysql-%E6%98%AF%E6%80%8E%E4%B9%88%E5%8A%A0%E8%A1%8C%E7%BA%A7%E9%94%81%E7%9A%84)

## 操作系统
### 内存管理
#### 内存分段
### 调度算法
#### 进程调度算法
- 先来先服务调度算法
- 最短作业优先调度算法
- 高响应比优先调度算法
- 时间片轮转调度算法
- 最高优先级调度算法
- 多级反馈队列调度算法
#### 内存置换算法
- 最佳页面置换算法（OPT）
- 先进先出置换算法（FIFO）
- 最近最久未使用的置换算法（LRU）
- 时钟页面置换算法（Lock）
- 最不常用置换算法（LFU）
#
### 琐碎
1. 磁盘读写的最小单位是扇区，扇区的大小只有 512B 大小，操作系统一次会读写多个扇区，所以操作系统的最小读写单位是块（Block）。Linux 中的块大小为 4KB，也就是一次磁盘 I/O 操作会直接读写 8 个扇区。
2. 堆空间由低地址向高地址扩展，栈空间由高地址向低地址扩展。
## 计算机网络
### TCP
#### 序号
1. 单纯的ACK报文段不消耗序号，即TCP头部的seq仍为上一次发送的TCP报文段seq。但通常TCP在接收到数据时并不立即发送ACK；相反，它推迟发送，以便将ACK与需要沿该方向发送的数据一起发送（有时称这种现象为数据捎带ACK）。
2. 即使**发送方**的同步(ACK=1)和结束(FIN=1)报文段不携带任何数据，它们也要占用一个序号值，即它们应收到的ack确认号为seq+1(seq为**发送方**的同步或结束报文的序号值)。
3. 消耗一个序列号意味着使用重传进行可靠传输，因此不消耗ACK序列号的ACK则不是。
4. 序号值是对应用层传来的程序数据的字节流进行编号，传输过程中产生的TCP头部不需要编号。


#### 拥塞控制
1. 快重传过程中，当收到三个重复的确认报文时，计算`ssthresh后`，`cwnd=ssthresh+3*MSS` (Maximum Segment Size ，TCP提交给IP层最大分段大小，不包含TCP Header和 TCP Option，只包含TCP Payload)，之所以`+3*MSS`，是因为发送方已经收到三个重复的ACK确认报文，表明有3个“老”的数据包离开了网络。
2. 快恢复时，当收到新的数据包的ACK时，把`cwnd`设置为第一步中的`ssthresh`的值，原因是因为该ACK确认了新的数据，说明从重复ACK时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态。
3. 快速恢复的思想是“数据包守恒”原则，即同一个时刻在网络中的数据包数量是恒定的，只有当“老”数据包离开了网络后，才能向网络中发送一个“新”的数据包，如果发送方收到一个重复的ACK，那么根据TCP的ACK机制就表明有一个数据包离开了网络，于是`cwnd`加1。


## 数据结构与算法
### 二叉树
#### 最优二叉树（哈夫曼树）
在构建最优二叉树时，n个叶子的哈夫曼树要经过n-1次合并，产生n-1个新结点。因此最终求得的哈夫曼树中共有2n-1个结点。

>e.g. 给定一个最优二叉树中的节点总数为123，我们可以通过以下计算来确定叶子节点的个数：
叶子节点个数 = （节点总数 + 1）/ 2
将节点总数替换为123，我们有：
叶子节点个数 = （123 + 1）/ 2 = 62
所以，这棵最优二叉树中有62个叶子节点。

## Linux
### Shell
#### `!`的使用
https://www.cnblogs.com/yy3b2007com/p/11267237.html
https://blog.csdn.net/donggua_fu/article/details/77387748 (好像不对)

### 链接
[有关链接的博客讲解](http://c.biancheng.net/linux/ln.html)
- 硬链接： 与普通文件没什么不同，inode都指向同一个文件在硬盘中的区块
- 软链接： 保存了其代表的文件的绝对路径，是另外一种文件，在硬盘上有独立的区块，访问时替换自身路径。类似于windows的快捷方式。
#### 为什么 ln 不允许硬链接到目录
Linux 系统中的硬链接有两个限制：
1. 不能跨越文件系统。
2. 不允许普通用户对目录作硬链接。

至于第一个限制，很好理解，而第二个就不那么好理解了。

我们对任何一个目录用 ls-l 命令都可以看到其链接数至少是 2，这也说明了系统中是存在基于目录的硬链接的，而且命令 ln -d（-d选项表示针对目录建立硬链接）也允许 root 用户尝试对目录作硬链接。这些都说明了系统限制对目录进行硬链接只是一个硬性规定，并不是逻辑上不允许或技术上不可行。那么操作系统为什么要进行这个限制呢？

这是因为，如果引入了对目录的硬连接就有可能在目录中引入循环链接，那么在目录遍历的时候系统就会陷入无限循环当中。也许有人会说，符号连接不也可以引入循环链接吗，那么为什么不限制目录的符号连接呢？

原因就在于，在 Linux 系统中，每个文件（目录也是文件）都对应着一个 inode 结构，其中 inode 数据结构中包含了文件类型（目录、普通文件、符号连接文件等）的信息，也就是说，操作系统在遍历目录时可以判断出其是否是符号连接。既然可以判断出它是否是符号连接，当然就可以采取一些措施来防范进入过大过深的循环层次，于是大部分系统会规定在连续遇到 8 个符号连接后就停止遍历。但是对于硬链接，由于操作系统中采用的数据结构和算法限制，目前是不能防范这种死循环的。

基于这样的考虑，系统不允许普通用户建立目录硬链接。


## 杂类
### 200G的字符串中有一对相同的字符串，如何用一台内存为200M的机器来进行查询？
答：使用哈希桶，共1024个桶
### JWT鉴权
[JWT&对称加密&非对称加密](https://blog.csdn.net/weixin_45139342/article/details/104599151)
### 原码、反码与补码
1. 补码的设立均是为了方便计算机内存进行减运算，即通过加一个负数的补码来实现减运算。
2. 若实现减运算，只用反码即可，但为什么要有补码呢？答：因为反码表示中0有两个表现方式，即0000 0000 和 1111 1111（均为反码，+0和-0）。
3. 从反码到补码的过程，用到了同余定理，补码在反码的基础上加一便相当于模数加1
4. 详见[原码、补码、反码的关系](https://www.cnblogs.com/goahead--linux/p/10904701.html)

